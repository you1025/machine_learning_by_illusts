# 基底関数として三角関数を用いた最小二乗学習
# φ = (1, sin(x*π/2), cos(x*π/2), sin(x*2π/2), cos(x*2π/2), … , sin(x*15π/2), cos(x*15π/2))

### データの作成

# 乱数を固定
# テキスト通りに記述しているが言語が異なるため再現は不可
rand('state', 0);
randn('state', 0);

n = 50;   # 学習データの標本サイズ
N = 1000; # 推測された関数をプロットする点の個数

x = linspace(-3, 3, n); # -3〜3 を n-1 等分
X = linspace(-3, 3, N); # -3〜3 を N-1 等分

# -3π〜3π を n-1 等分
pix = pi * x;

y0 = sin(pix) ./ (pix) + 0.1 * x; # 真の値からなる系列
y  = y0 + 0.05 * randn(n, 1)';    # 真の値にノイズを加えた系列


### 計画行列の生成
# p: n x 16 行列
# P: N x 16 行列 (予測用)

# 1列目を全て 1 とする
p(:,1) = ones(n, 1);  # n行
P(:,1) = ones(N, 1);  # N行

# 2列目以降の奇数列に sin(x/2) を、偶数行に cos(x/2) を格納
for j=1:15
  # p の作成
  p(:, 2*j)   = sin(j*x/2);
  p(:, 2*j+1) = cos(j*x/2);

  # P の作成
  P(:, 2*j)   = sin(j*X/2);
  P(:, 2*j+1) = cos(j*X/2);
end


### パラメータ(theta)の導出
#theta = pinv(p) * y'; # 一般化逆行列(pinv)を用いる
theta = p \ y';       # テキスト通り: p が正則ならば inverse(p) * y' と同値だが正則でないので最小ノルム解を算出
yhat = P * theta;     # y の推測値からなる系列


### 描画
figure(1);
clf;
hold on;
axis([-2.8 2.8 -0.5 1.2]);
plot(x, y0, 'b-');    # 学習データをプロット
plot(X, yhat, 'g-');  # 推測された曲線(滑らか)を表示
plot(x, y, 'r@');     # 真の値を折れ線で表示
